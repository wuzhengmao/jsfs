package org.mingy.kernel.context;import java.util.ArrayList;import java.util.List;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;import org.mingy.kernel.config.ApplicationConfig;import org.mingy.kernel.util.Strings;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;import org.springframework.jmx.export.annotation.ManagedAttribute;import org.springframework.jmx.export.annotation.ManagedOperation;import org.springframework.jmx.export.annotation.ManagedResource;import org.springframework.util.ResourceUtils;/** * 使用Spring自动载入ApplicationConfig配置信息的容器类。<br> * 如果定义了refreshInterval，则还可以实现定义扫描properties的配置更改。<br> * <br> * 要使用本功能，需要在spring的加载配置文件（applicationContext-XXXX.xml）中进行如下配置：<br> * &lt;bean class="org.mx.kernel.context.ApplicationConfigContext"><br> * &nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="configLocation" * value="${logs.root}/config.properties" /><br> * &nbsp;&nbsp;&nbsp;&nbsp;&lt;property name="refreshInterval" value="3600" * />&lt;!-- 这表示每隔1小时载入一次 --><br> * &lt/bean> *  * @author Mingy *  */@ManagedResource(description = "Application Configuration Context")public class ApplicationConfigContext implements InitializingBean,		DisposableBean {	private static final Log logger = LogFactory			.getLog(ApplicationConfigContext.class);	private static List<String> configLocationList = new ArrayList<String>(); // 整个应用配置文件名列表	private static List<Long> refreshIntervalList = new ArrayList<Long>(); // 整个应用周期性载入等待时间列表	private String configLocation = "config.properties"; // 默认的配置文件名	private long refreshInterval = 0; // 周期性载入等待时间，小于等于0表示不周期性载入。	/**	 * 完成配置，由Spring自动调用	 */	public void afterPropertiesSet() throws Exception {		configLocation = Strings.fillVariable(configLocation);		init(configLocation, refreshInterval);	}	/**	 * 需要撤销了，由Spring自动调用	 */	public void destroy() throws Exception {		ApplicationConfig.getInstance().clear();	}	@ManagedAttribute(description = "Configurations location")	public String getConfigLocation() {		return configLocation;	}	/**	 * 重新加载当前实例对应的配置。	 */	@ManagedOperation(description = "Reload this configurations")	public void reload() {		try {			String[] configFiles = Strings.split(getConfigLocation(), ",;\t\n",					true, true);			for (int i = 0; i < configFiles.length; i++) {				String file = configFiles[i];				if (file.startsWith(ApplicationConfig.TYPE_CLASSPATH)) {					ApplicationConfig.getInstance().loadFromURL(							ResourceUtils.getURL(file));				} else {					ApplicationConfig.getInstance().loadFromFile(file);				}			}		} catch (Exception e) {			if (logger.isErrorEnabled()) {				logger.error("reload failed", e);			}		}	}	/**	 * 注入的Config文件列表，用分隔符分割，分隔符类型参见StringUtil中的split方法。	 * 	 * @param configLocation	 *            Config文件列表，如果是从类路径中载入，则文件以“CLASSPATH:”开头标识；否则为文件系统载入。	 * @see StringUtil#split(String, boolean, boolean)	 * @see StringUtil#DELIMITERS	 */	public void setConfigLocation(String configLocation) {		this.configLocation = configLocation;		configLocationList				.add(configLocationList.lastIndexOf(configLocation) > -1 ? configLocationList						.lastIndexOf(configLocation) : 0, configLocation);// 要和refreshInterval的位置一一对应		refreshIntervalList.add(refreshInterval);// 加一次默认的，若后面设置了，则替换默认的	}	/**	 * 注入的周期性载入等待时间，单位为秒。	 * 	 * @param delay	 *            等待时间，如果设置为小于等于0的值，则表示不周期性载入，仅载入一次。	 */	public void setRefreshInterval(long delay) {		this.refreshInterval = delay;		refreshIntervalList				.add(refreshIntervalList.lastIndexOf(refreshInterval) > -1 ? refreshIntervalList						.lastIndexOf(refreshInterval) : 0, delay);// 要和configLocation的位置一一对应		configLocationList.add(configLocation);// 加一次默认的，若后面设置了，则替换默认的	}	private void init(String configLocation, long refreshInterval)			throws Exception {		String[] configFiles = Strings.split(configLocation, ",;\t\n", true,				true);		// 将文件列表分成两组：类路径载入和文件系统载入		List<String> fromClassPath = new ArrayList<String>();		List<String> fromFile = new ArrayList<String>();		for (int i = 0; i < configFiles.length; i++) {			String file = configFiles[i];			if (file.toLowerCase().startsWith(					ApplicationConfig.TYPE_CLASSPATH.toLowerCase())) {				fromClassPath.add(file);			} else {				fromFile.add(file);			}		}		// 先从类路径中载入，因为类路径中的配置文件不会周期性载入		for (String file : fromClassPath) {			ApplicationConfig.getInstance().loadFromURL(					ResourceUtils.getURL(file));		}		// 然后从文件系统中载入		ApplicationConfig.getInstance().loadFromFile(fromFile, refreshInterval);	}}